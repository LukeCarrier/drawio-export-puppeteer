<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Draw.io exporter</title>

    <link rel="stylesheet" href="vendor/drawio/src/main/webapp/mxgraph/css/common.css" charset="UTF-8" type="text/css">
    <style>
      body {
        margin: 0;
      }

      @media print {
        span.MathJax_SVG svg {
          shape-rendering: crispEdges;
        }
        table.mxPageSelector {
          display: none;
        }
        hr.mxPageBreak {
          display: none;
        }
      }

      @media screen {
        table.mxPageSelector {
          position: fixed;
          right: 10px;
          top: 10px;
          font-family: Arial;
          font-size: 10pt;
          border: solid 1px darkgray;
          background: white;
          border-collapse: collapse;
        }
        table.mxPageSelector td {
          border: solid 1px gray;
          padding: 4px;
        }
        body.mxPage {
          background: gray;
        }
      }
    </style>

    <script>
      const mxLoadStylesheets = false;
    </script>
    <script src="vendor/drawio/src/main/webapp/js/app.min.js"></script>
    <script>
      Editor.initMath('vendor/drawio/src/main/webapp/math/MathJax.js');

      // Exposed for Puppeteer
      function render(input, pageIndex, format) {
        const TRANSPARENT_COLORS = [
          '',
          'none',
        ];
        const TRANSPARENT_FORMATS = [
          'png',
          'svg',
        ];

        console.debug('Rendering page', pageIndex, 'of input', input, 'as', format);

        function initializeGraph(body) {
          console.debug('Initialising empty document');
          document.body.innerHTML = '';
          const container = document.createElement('div');
          container.id = 'graph';
          container.style.width = '100%';
          container.style.height = '100%';
          body.appendChild(container);

          console.debug('Initialising empty graph');
          const graph = new Graph(container);
          graph.setEnabled(false);
          graph.foldingEnabled = false;

          return {container, graph};
        }

        function monkeypatchGraph(graph) {
          console.debug('Monkey patching mxGraph to disable custom links');

          const graphGetLinkForCell = graph.getLinkForCell;
          graph.getLinkForCell = function(cell) {
            const link = graphGetLinkForCell.apply(this, arguments);
            if (link != null && this.isCustomLink(link)) {
              link = null;
            }

            return link;
          };

          const cellRendererRedrawLabelShape = graph.cellRenderer.redrawLabelShape;
          graph.cellRenderer.redrawLabelShape = function(shape) {
            cellRendererRedrawLabelShape.apply(this, arguments);
            if (shape.node != null) {
              const links = shape.node.getElementsByTagName('a');

              for (const i = 0; i < links.length; i++)
              {
                const href = links[i].getAttribute('href');
                if (href != null && graph.isCustomLink(href)) {
                  links[i].setAttribute('href', '#');
                }
              }
            }
          };

          // Fits the number of background pages to the graph
          if (false /* PDF specific */) {
            graph.view.getBackgroundPageBounds = function() {
              var layout = this.graph.getPageLayout();
              var page = this.graph.getPageSize();

              return new mxRectangle(
                  this.scale * (this.translate.x + layout.x * page.width),
                  this.scale * (this.translate.y + layout.y * page.height),
                  this.scale * layout.width * page.width,
                  this.scale * layout.height * page.height);
            };
          }
        }

        function parseInput(input) {
          console.debug('Parsing input')
          const doc = mxUtils.parseXml(input);

          const node = Editor.extractGraphModel(doc.documentElement, true);
          const xmlDoc = node.ownerDocument;

          if (xmlDoc.documentElement.nodeName !== 'mxfile') {
            throw new Error(`Unsupported root node name ${xmlDoc.documentElement.nodeName}`);
          }

          return {node, xmlDoc};
        }

        function decodeDiagram(graph, xmlDoc) {
          const codec = new mxCodec(xmlDoc);
          const model = graph.getModel();
          codec.decode(xmlDoc.documentElement, model);

          console.debug('decoded graph doc into model', model);
        }

        function normalizeBackgroundColor(xmlDoc, format) {
          let backgroundColor = xmlDoc.documentElement.getAttribute('background');

          // Handle some different values that really mean transparent
          if (TRANSPARENT_COLORS.includes(backgroundColor)) {
            backgroundColor = null;
          }

          // Fall back to white for formats that don't support transparency
          if (!TRANSPARENT_FORMATS.includes(format)) {
            backgroundColor = '#ffffff';
          }

          return backgroundColor;
        }

        function scaleGraph(graph) {
          const bounds = graph.getGraphBounds();
          const pageWidth = 800
          let scale;

          if (bounds.width < pageWidth & bounds.height < 1.5 * pageWidth) {
            scale = 4;
          } else if (bounds.width < 2 * pageWidth & bounds.height < 3 * pageWidth) {
            scale = 3;
          } else if (bounds.width < 4 * pageWidth && bounds.height < 6 * pageWidth) {
            scale = 2;
          }

          graph.view.scaleAndTranslate(scale, Math.floor(bounds.x), Math.floor(bounds.y));

          return {bounds, scale};
        }

        function renderPage(body, xmlDoc) {
          const {container, graph} = initializeGraph(body);
          monkeypatchGraph(graph);
          decodeDiagram(graph, xmlDoc);

          document.body.style.backgroundColor = normalizeBackgroundColor(xmlDoc, format);
          const {bounds, scale} = scaleGraph(graph);
          console.debug('graph reported bounds', bounds, 'and scale', scale);
          return {bounds, scale};
        }

        function writeResultInfo(body, pageCount, pageId, bounds, scale) {
          const indicator = document.createElement('div');
          indicator.id = 'result-info';
          indicator.style.display = 'none';

          indicator.setAttribute('data-page-count', pageCount);
          indicator.setAttribute('data-page-id', pageId);

          indicator.setAttribute('data-bounds-x', bounds.x);
          indicator.setAttribute('data-bounds-y', bounds.y);
          indicator.setAttribute('data-bounds-width', bounds.width);
          indicator.setAttribute('data-bounds-height', bounds.height);

          indicator.setAttribute('data-scale', scale);

          document.body.appendChild(indicator);
        }

        const {xmlDoc: rootXmlDoc} = parseInput(input);
        const diagrams = rootXmlDoc.documentElement.getElementsByTagName('diagram');

        const diagramNode = Editor.parseDiagramNode(diagrams[pageIndex]);
        const diagramXmlDoc = diagramNode.ownerDocument;
        const diagramId = diagrams[pageIndex].getAttribute('id');

        const {bounds, scale} = renderPage(document.body, diagramXmlDoc);
        writeResultInfo(document.body, diagrams.length, diagramId, bounds, scale);
      }
    </script>
  </head>
  <body></body>
</html>
